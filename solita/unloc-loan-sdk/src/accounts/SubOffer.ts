/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

import * as web3 from '@solana/web3.js'
import * as beet from '@metaplex-foundation/beet'
import * as beetSolana from '@metaplex-foundation/beet-solana'

/**
 * Arguments used to create {@link SubOffer}
 * @category Accounts
 * @category generated
 */
export type SubOfferArgs = {
  bump: number
  borrower: web3.PublicKey
  nftMint: web3.PublicKey
  offerMint: web3.PublicKey
  offerMintDecimals: number
  state: number
  offer: web3.PublicKey
  subOfferNumber: beet.bignum
  lender: web3.PublicKey
  offerVault: web3.PublicKey
  offerAmount: beet.bignum
  repaidAmount: beet.bignum
  lenderClaimedAmount: beet.bignum
  borrowerClaimedAmount: beet.bignum
  loanStartedTime: beet.bignum
  loanEndedTime: beet.bignum
  loanDuration: beet.bignum
  aprNumerator: beet.bignum
  creationDate: beet.bignum
  totalPoint: beet.bignum
  collectionPoint: beet.bignum
  lenderHasClaimedRewards: boolean
  borrowerHasClaimedRewards: boolean
  lastLenderClaim: beet.bignum
  lastBorrowerClaim: beet.bignum
  rps: beet.bignum
  lenderRewardDebt: beet.bignum
  borrowerRewardDebt: beet.bignum
  reserved: beet.bignum[] /* size: 7 */
}

export const subOfferDiscriminator = [188, 236, 173, 43, 148, 14, 172, 76]
/**
 * Holds the data for the {@link SubOffer} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
export class SubOffer implements SubOfferArgs {
  private constructor(
    readonly bump: number,
    readonly borrower: web3.PublicKey,
    readonly nftMint: web3.PublicKey,
    readonly offerMint: web3.PublicKey,
    readonly offerMintDecimals: number,
    readonly state: number,
    readonly offer: web3.PublicKey,
    readonly subOfferNumber: beet.bignum,
    readonly lender: web3.PublicKey,
    readonly offerVault: web3.PublicKey,
    readonly offerAmount: beet.bignum,
    readonly repaidAmount: beet.bignum,
    readonly lenderClaimedAmount: beet.bignum,
    readonly borrowerClaimedAmount: beet.bignum,
    readonly loanStartedTime: beet.bignum,
    readonly loanEndedTime: beet.bignum,
    readonly loanDuration: beet.bignum,
    readonly aprNumerator: beet.bignum,
    readonly creationDate: beet.bignum,
    readonly totalPoint: beet.bignum,
    readonly collectionPoint: beet.bignum,
    readonly lenderHasClaimedRewards: boolean,
    readonly borrowerHasClaimedRewards: boolean,
    readonly lastLenderClaim: beet.bignum,
    readonly lastBorrowerClaim: beet.bignum,
    readonly rps: beet.bignum,
    readonly lenderRewardDebt: beet.bignum,
    readonly borrowerRewardDebt: beet.bignum,
    readonly reserved: beet.bignum[] /* size: 7 */
  ) {}

  /**
   * Creates a {@link SubOffer} instance from the provided args.
   */
  static fromArgs(args: SubOfferArgs) {
    return new SubOffer(
      args.bump,
      args.borrower,
      args.nftMint,
      args.offerMint,
      args.offerMintDecimals,
      args.state,
      args.offer,
      args.subOfferNumber,
      args.lender,
      args.offerVault,
      args.offerAmount,
      args.repaidAmount,
      args.lenderClaimedAmount,
      args.borrowerClaimedAmount,
      args.loanStartedTime,
      args.loanEndedTime,
      args.loanDuration,
      args.aprNumerator,
      args.creationDate,
      args.totalPoint,
      args.collectionPoint,
      args.lenderHasClaimedRewards,
      args.borrowerHasClaimedRewards,
      args.lastLenderClaim,
      args.lastBorrowerClaim,
      args.rps,
      args.lenderRewardDebt,
      args.borrowerRewardDebt,
      args.reserved
    )
  }

  /**
   * Deserializes the {@link SubOffer} from the data of the provided {@link web3.AccountInfo}.
   * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
   */
  static fromAccountInfo(
    accountInfo: web3.AccountInfo<Buffer>,
    offset = 0
  ): [SubOffer, number] {
    return SubOffer.deserialize(accountInfo.data, offset)
  }

  /**
   * Retrieves the account info from the provided address and deserializes
   * the {@link SubOffer} from its data.
   *
   * @throws Error if no account info is found at the address or if deserialization fails
   */
  static async fromAccountAddress(
    connection: web3.Connection,
    address: web3.PublicKey
  ): Promise<SubOffer> {
    const accountInfo = await connection.getAccountInfo(address)
    if (accountInfo == null) {
      throw new Error(`Unable to find SubOffer account at ${address}`)
    }
    return SubOffer.fromAccountInfo(accountInfo, 0)[0]
  }

  /**
   * Provides a {@link web3.Connection.getProgramAccounts} config builder,
   * to fetch accounts matching filters that can be specified via that builder.
   *
   * @param programId - the program that owns the accounts we are filtering
   */
  static gpaBuilder(
    programId: web3.PublicKey = new web3.PublicKey(
      '6oVXrGCdtnTUR6xCvn2Z3f2CYaiboAGar1DKxzeX8QYh'
    )
  ) {
    return beetSolana.GpaBuilder.fromStruct(programId, subOfferBeet)
  }

  /**
   * Deserializes the {@link SubOffer} from the provided data Buffer.
   * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
   */
  static deserialize(buf: Buffer, offset = 0): [SubOffer, number] {
    return subOfferBeet.deserialize(buf, offset)
  }

  /**
   * Serializes the {@link SubOffer} into a Buffer.
   * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
   */
  serialize(): [Buffer, number] {
    return subOfferBeet.serialize({
      accountDiscriminator: subOfferDiscriminator,
      ...this,
    })
  }

  /**
   * Returns the byteSize of a {@link Buffer} holding the serialized data of
   * {@link SubOffer}
   */
  static get byteSize() {
    return subOfferBeet.byteSize
  }

  /**
   * Fetches the minimum balance needed to exempt an account holding
   * {@link SubOffer} data from rent
   *
   * @param connection used to retrieve the rent exemption information
   */
  static async getMinimumBalanceForRentExemption(
    connection: web3.Connection,
    commitment?: web3.Commitment
  ): Promise<number> {
    return connection.getMinimumBalanceForRentExemption(
      SubOffer.byteSize,
      commitment
    )
  }

  /**
   * Determines if the provided {@link Buffer} has the correct byte size to
   * hold {@link SubOffer} data.
   */
  static hasCorrectByteSize(buf: Buffer, offset = 0) {
    return buf.byteLength - offset === SubOffer.byteSize
  }

  /**
   * Returns a readable version of {@link SubOffer} properties
   * and can be used to convert to JSON and/or logging
   */
  pretty() {
    return {
      bump: this.bump,
      borrower: this.borrower.toBase58(),
      nftMint: this.nftMint.toBase58(),
      offerMint: this.offerMint.toBase58(),
      offerMintDecimals: this.offerMintDecimals,
      state: this.state,
      offer: this.offer.toBase58(),
      subOfferNumber: (() => {
        const x = <{ toNumber: () => number }>this.subOfferNumber
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      lender: this.lender.toBase58(),
      offerVault: this.offerVault.toBase58(),
      offerAmount: (() => {
        const x = <{ toNumber: () => number }>this.offerAmount
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      repaidAmount: (() => {
        const x = <{ toNumber: () => number }>this.repaidAmount
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      lenderClaimedAmount: (() => {
        const x = <{ toNumber: () => number }>this.lenderClaimedAmount
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      borrowerClaimedAmount: (() => {
        const x = <{ toNumber: () => number }>this.borrowerClaimedAmount
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      loanStartedTime: (() => {
        const x = <{ toNumber: () => number }>this.loanStartedTime
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      loanEndedTime: (() => {
        const x = <{ toNumber: () => number }>this.loanEndedTime
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      loanDuration: (() => {
        const x = <{ toNumber: () => number }>this.loanDuration
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      aprNumerator: (() => {
        const x = <{ toNumber: () => number }>this.aprNumerator
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      creationDate: (() => {
        const x = <{ toNumber: () => number }>this.creationDate
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      totalPoint: (() => {
        const x = <{ toNumber: () => number }>this.totalPoint
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      collectionPoint: (() => {
        const x = <{ toNumber: () => number }>this.collectionPoint
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      lenderHasClaimedRewards: this.lenderHasClaimedRewards,
      borrowerHasClaimedRewards: this.borrowerHasClaimedRewards,
      lastLenderClaim: (() => {
        const x = <{ toNumber: () => number }>this.lastLenderClaim
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      lastBorrowerClaim: (() => {
        const x = <{ toNumber: () => number }>this.lastBorrowerClaim
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      rps: (() => {
        const x = <{ toNumber: () => number }>this.rps
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      lenderRewardDebt: (() => {
        const x = <{ toNumber: () => number }>this.lenderRewardDebt
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      borrowerRewardDebt: (() => {
        const x = <{ toNumber: () => number }>this.borrowerRewardDebt
        if (typeof x.toNumber === 'function') {
          try {
            return x.toNumber()
          } catch (_) {
            return x
          }
        }
        return x
      })(),
      reserved: this.reserved,
    }
  }
}

/**
 * @category Accounts
 * @category generated
 */
export const subOfferBeet = new beet.BeetStruct<
  SubOffer,
  SubOfferArgs & {
    accountDiscriminator: number[] /* size: 8 */
  }
>(
  [
    ['accountDiscriminator', beet.uniformFixedSizeArray(beet.u8, 8)],
    ['bump', beet.u8],
    ['borrower', beetSolana.publicKey],
    ['nftMint', beetSolana.publicKey],
    ['offerMint', beetSolana.publicKey],
    ['offerMintDecimals', beet.u8],
    ['state', beet.u8],
    ['offer', beetSolana.publicKey],
    ['subOfferNumber', beet.u64],
    ['lender', beetSolana.publicKey],
    ['offerVault', beetSolana.publicKey],
    ['offerAmount', beet.u64],
    ['repaidAmount', beet.u64],
    ['lenderClaimedAmount', beet.u64],
    ['borrowerClaimedAmount', beet.u64],
    ['loanStartedTime', beet.u64],
    ['loanEndedTime', beet.u64],
    ['loanDuration', beet.u64],
    ['aprNumerator', beet.u64],
    ['creationDate', beet.u64],
    ['totalPoint', beet.u128],
    ['collectionPoint', beet.u128],
    ['lenderHasClaimedRewards', beet.bool],
    ['borrowerHasClaimedRewards', beet.bool],
    ['lastLenderClaim', beet.i64],
    ['lastBorrowerClaim', beet.i64],
    ['rps', beet.u128],
    ['lenderRewardDebt', beet.u128],
    ['borrowerRewardDebt', beet.u128],
    ['reserved', beet.uniformFixedSizeArray(beet.u128, 7)],
  ],
  SubOffer.fromArgs,
  'SubOffer'
)
